#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
import glob
import os
import re
import sys
import codecs
import getopt
import logging
logging.basicConfig(level=logging.INFO, #DEBUG
    format='%(asctime)s %(name)s: %(levelname)-8s %(message)s',
    datefmt='%H:%M:%S'
    #filename='./hoo2013.log', #filemode='w', datefmt='%Y-%m-%d %H:%M:%S',
)
console = logging.StreamHandler()
console.setLevel(logging.INFO)
gl = logging.getLogger('ROC') #global logger

'''
brings Mexican markets markets 0 0 1 cg k 2 1 1 2 1 [ markets 2 ]
Mexican markets to to -0.584963 0.918296 1.5 cg k 2 1 2 3 1 [ to 2 into 1 ]

durian:lm pberck$ python ../../../etc/roc.py -f rmt.t1e2b.l2r0_67990.px >tmp
plot [0:1][0:1] "tmp" using 6:7:1 with labels, "tmp" using 6:7 with points 
or
plot [0:1][0:1] "tmp" using 6:7 with points

Processes all *.px files in a directory with the -d option. In that case
it parses the filename for the context, so it will only work with wopr
autogenerated files.
'''

# ----------------------------------------------------------------------------

# Hold the PN matrix for a word
class Matrix():
    def __init__(self, word):
        self.word = word
        self.classfp = [[word, 0]] #positive, correct
        self.classfn = [] #negative, incorrect
        self.TP = 0 #TP classf should be target/word, and classf == target
        self.FP = 0 #FP classf is a FP for other Matrix where classf == Matrix(target/word)
        self.FN = 0 #FN classf should be target/word, and classf != target
        self.TN = 0 #TN count of others, i.e where both Matrix(target/word) and Matrix(classf) != classf
                    #   this equals total-words - TP - FP - FN (or maybe look at distribution?)
    def to_str(self):
        return self.word+":"+str(self.TP)+" "+str(self.FP)+" "\
            +str(self.FN)+" "+str(self.TN)+" "\
            +repr(self.classfp)+" "+repr(self.classfn)
    def add_classification(self, classf):
        if self.word == classf:
            self.TP += 1
            self.classfp[0][1] += 1
        else:
            self.FN += 1
            tn = [x for x in self.classfn if x[0] == classf]
            if tn:
                tn[0][1] += 1
            else:
                self.classfn.append([classf,1])
    """
    Returns one [word, freq] item, or None if the word
    is not found in the classfn list.
    """
    def get_classfn(self, word):
        res = [x for x in self.classfn if x[0] == word]
        if res:
            return res[0]
        return None
    def accuracy(self):
        return float((self.TP + self.TN)) / float((self.TP + self.FP + self.FN + self.TN))
    def precision(self):
        try:
            return float(self.TP) / float( self.TP + self.FP )
        except (ZeroDivisionError):
            return -1 # hmmm...undefined?
    def recall(self):
        try:
            return float(self.TP) / float( self.TP + self.FN )
        except (ZeroDivisionError):
            return -1 #hmmm...undefined?
    def sensitivity(self):
        return float(self.TP) / float( self.TP + self.FN )
    def TPR(self):
        return self.sensitivity()
    def FPR(self):
        return float(self.FP) / float( self.FP + self.TN )
    def specificity(self):
        return float(self.TN) / float(self.FP + self.TN)
    def TNR(self):
        return self.specificity()
    #return float(2 * ( (self.precision()*self.recall()) / (self.precision()+self.recall()) ) )
    def Fscore(self):
        return float(2 * self.TP) / float((2*self.TP) + self.FP + self.FN)
    def ROCpoint(self):
        return ( self.FPR(), self.TPR() )

# ----------------------------------------------------------------------------

def process_px(pxfile, lc, rc):
    target_pos = lc + rc
    word_pos   = target_pos
    classf_pos = lc + rc + 1

    # Pass one, read targets for a word list.
    #
    words = []
    matrices = []
    classifications = 0
    gl.info("Reading file: "+pxfile)
    f = codecs.open(pxfile, "r", "utf-8")
    for line in f:
        if line[0] == "#":
            continue
        classifications += 1
        bits = line.split()
        word = bits[target_pos]
        classf = bits[classf_pos]
        #gl.info(bits[target_pos]+"/"+bits[classf_pos])
        if word not in words:
            words.append(word)
            wordm = Matrix(word)
            matrices.append(wordm)
        else:
            wordm = [m for m in matrices if m.word == word][0]
        wordm.add_classification(classf)
    f.close()

    gl.info("Number of classifications: "+str(classifications))
    gl.info("Calculating stats.")

    # Pass two, look up words in other words :-)
    #
    for wordm in matrices:
        gl.debug(wordm.to_str())
        fword = wordm.word #this word we focus on
        # see if this word is classified elsewhere
        fps = [(x.word, x.get_classfn(fword)) for x in matrices if x.get_classfn(fword) != None]
        if fps:
            gl.debug("FPs for: "+wordm.word)
            # the x in [fps] means x has been classified as fword.
            # this is called a false positive for the current fword
            gl.debug("FPs: "+repr([x for x in fps]))
            for fp in fps:
                wordm.FP += fp[1][1]
            gl.debug(wordm.to_str())

    gl.info("Calculate TN from other stats.")

    # Pass three, fill in the TN value
    #
    for wordm in matrices:
        wordm.TN = classifications - wordm.TP - wordm.FP - wordm.FN
        #gl.info(wordm.to_str())
        #gl.info( str(wordm.accuracy())+"/"+str(wordm.precision())+"/"+str(wordm.sensitivity())+"/"+str(wordm.FPR())\
        #         +"/"+str(wordm.specificity())+"/"+str(wordm.Fscore())+"/"+repr(wordm.ROCpoint()) )

    gl.info("Creating gnuplot output.")

    # Gnuplot output
    # python roc.py -f bla.px > tmp
    # plot [0:1][0:1]"tmp" using 2:3 with points
    print "# word TP FP FN TN pt0 pt1 accuracy precision recall Fscore"
    for wordm in matrices:
        pt = wordm.ROCpoint()
        if True or pt[0] < pt[1]: #only top-left
            print wordm.word,wordm.TP,wordm.FP,wordm.FN,wordm.TN,pt[0],pt[1],wordm.accuracy(),wordm.precision(),wordm.recall(),wordm.Fscore()

    gl.info("Ready")

# ----------------------------------------------------------------------------

pxfile = None
lc = 2
rc = 0
do_dir = False

try:
    opts, args = getopt.getopt(sys.argv[1:], "df:l:r:", ["lc=","rc="])
except getopt.GetoptError, err:
    # print help information and exit:
    gl.error(str(err))
    sys.exit(2)
for o, a in opts:
    if o in ("-f"):
        pxfile = a
    elif o in ("-d"):
        do_dir = True
    elif o in ("-l"):
        lc = int(a)
    elif o in ("-r"):
        rc = int(a)
    else:
        gl.error("Unhandled option")
        assert False, "unhandled option"

if do_dir:
    px_str = "(.*)px$"
    px_re  = re.compile(px_str, re.IGNORECASE)
    # en-es.es.t1000.l1r0_TRIBL2_REF.px
    re1str = ".*l(\d+)r(\d+).*"
    re1 = re.compile(re1str, re.IGNORECASE)

    px_files = os.listdir( "." )
    px_files = filter(px_re.search, px_files)

    for px_file in px_files:
        match = False
        m = re1.match(px_file)
        if m:
            match = True
            gl.info(px_file)
            lc = int(m.group(1))
            rc = int(m.group(2))
            process_px(px_file, lc, rc)
else:
    if not pxfile:
        gl.error("Need at least: -f .px file.")
        sys.exit(2)
    process_px(pxfile, lc, rc)
    
'''
wordm = Matrix("test")
wordm.TP = 63
wordm.FP = 28
wordm.FN = 37
wordm.TN = 72
gl.info( str(wordm.TPR())+"/"+str(wordm.FPR())+"/"+str(wordm.Fscore())+"/"+str(wordm.ROCpoint())+"/"+str(wordm.accuracy()) )
'''
